INFO MPORTANTE 

-os coelhos movem se primeiro e depois as foxes
-os coelhos tentam mover se para celulas adjacentes vazias, se não houver celulas vazias ficam no mesmo lugar
-as foxes tentam mover se para celulas adjacentes que contenham coelhos, se não houver coelhos em nenhuma celula adjacente movem-se para celulas vazias
-as rocks n se mexem
-os coelhos e as foxes podem spawnar novas creatures 
 caso tenham chegado a idade de reprod definida no input
-swap worlds contem o novo mundo com as novas posições
- tanto foxes como rabbbits movem-se no sentido horário (Norte -> Este -> Sul -> Oeste)
-não se usou MPI porque o objetivo do trabalho era trabalhar com memoria partilhada e não distribuida


CÓDIGO

- O #pragma omp critical cria uma secção crítica - um bloco de código que apenas uma thread pode executar de cada vez.

typedef struct object_ {
    char type;      // 'R' (rabbit), 'F' (fox), '*' (rock), ' ' (vazio)
    int num_gen;    // Gerações desde nascimento/última procriação
    int num_food;   // Gerações desde última refeição (só foxes)
} object;
```

**Inicialização:**
- Rabbits: `num_gen = GEN_PROC_RABBITS`, `num_food = 0`
- Foxes: `num_gen = GEN_PROC_FOXES`, `num_food = GEN_FOOD_FOXES`
- Rocks: `num_gen = 0`, `num_food = 0`

### **Swap Worlds:**
- `world` = mundo atual (leitura)
- `new_world` = mundo seguinte (escrita)
- `swap_worlds()` **troca os ponteiros** (não copia dados)
- Após swap, `world` tem as novas posições

### **Reset New World:**
- Limpa todas as células de `new_world` **exceto rocks ('*')**
- Rocks permanecem sempre no mesmo lugar

### **Copy Rabbits:**
- Copia todos os rabbits de `world` para `new_world`
- Usado após mover rabbits e antes de mover foxes
- Garante que foxes vêem os rabbits nas novas posições

### **Paralelização - Pontos Críticos:**

**Race Conditions:**
- Quando rabbits/foxes tentam mover para a **mesma célula**
- Solução: usar `#pragma omp critical` ao escrever em `new_world`

**Divisão de Trabalho:**
- Dividir matriz por **linhas** (horizontal)
- Usar `schedule(dynamic)` para balanceamento
- Cada thread processa um conjunto de linhas

**Sincronização:**
- Barreira implícita no fim de cada `#pragma omp parallel for`
- Garante que todos os rabbits/foxes moveram antes de fazer swap

**Leitura vs Escrita:**
- `world` é **só leitura** (thread-safe)
- `new_world` precisa de **sincronização** (escrita concorrente)

### **Detalhes de Implementação:**

**Move Rabbit/Fox:**
- Sempre lê de `world` (estado atual)
- Sempre escreve em `new_world` (próximo estado)
- Nunca modifica `world` durante movimento

**Procriação:**
- Verifica `num_gen >= GEN_PROC_*` **antes de mover**
- Se true: escreve bebé em `new_world[x][y]` (posição atual)
- Reseta `num_gen = 0` do pai
- Pai move com `num_gen` incrementado para 1

**Morte:**
- Rabbits morrem em conflitos (não são escritos em `new_world`)
- Foxes morrem de fome (`num_food > GEN_FOOD_FOXES`)
- Simplesmente não são colocados em `new_world`

### **Output Final:**
```
GEN_PROC_RABBITS GEN_PROC_FOXES GEN_FOOD_FOXES 0 R C N_OBJECTS
TIPO X Y
TIPO X Y
...